{"version":3,"file":"index.js","sources":["../source/helpers/tree.ts"],"sourcesContent":["enum Kind {\r\n  ROOT,\r\n  STATIC,\r\n  PARAMETER,\r\n  CATCH_ALL,\r\n}\r\n\r\ntype Nullable<V> = V | null\r\n\r\ninterface Node<P, K = Kind> {\r\n  type: K\r\n  path: string\r\n  data: Nullable<P>\r\n  priority: number\r\n\r\n  childIndex: string\r\n  childValues: Node<P>[]\r\n  childWild: Nullable<Node<P, Kind.PARAMETER | Kind.CATCH_ALL>>\r\n}\r\n\r\nconst MULTI_SLASH_REGEX = /\\/+|(?<!\\/)($|^)/g\r\n\r\nexport class Tree<P> {\r\n  root: Node<P, Kind.ROOT> = {\r\n    type: Kind.ROOT,\r\n    path: \"/\",\r\n    data: null,\r\n    priority: 0,\r\n\r\n    childIndex: \"\",\r\n    childValues: [],\r\n    childWild: null,\r\n  }\r\n\r\n  /** Add new node */\r\n  public add(path: string, data: P) {\r\n    this.findAndInsert(path.replace(MULTI_SLASH_REGEX, \"/\"), data, this.root)\r\n  }\r\n\r\n  /** Finds branch and inserts node */\r\n  private findAndInsert(path: string, data: P, node: Node<P>): void {\r\n    const commonPrefixLength = this.findCommonPrefixLength(path, node.path)\r\n    if (commonPrefixLength === 0) throw new Error(\"Cannot add child node\")\r\n\r\n    // Split edge\r\n    if (commonPrefixLength < node.path.length) {\r\n      const child: Node<P> = {\r\n        path: node.path.slice(commonPrefixLength),\r\n        type: node.type,\r\n        data: node.data,\r\n        priority: node.priority,\r\n        childIndex: node.childIndex,\r\n        childValues: node.childValues,\r\n        childWild: node.childWild,\r\n      }\r\n\r\n      node.type = Kind.STATIC\r\n      node.data = null\r\n      node.childIndex = node.path[commonPrefixLength]\r\n      node.path = node.path.slice(0, commonPrefixLength)\r\n      node.priority += 1\r\n      node.childValues = [child]\r\n      node.childWild = null\r\n    }\r\n\r\n    // Add child node\r\n    if (commonPrefixLength < path.length) {\r\n      path = path.slice(commonPrefixLength)\r\n      const childIndex = path[0]\r\n\r\n      for (let index = 0; index < node.childIndex.length; index++)\r\n        if (childIndex === node.childIndex[index]) {\r\n          node.priority += 1\r\n          this.findAndInsert(path, data, node.childValues[index])\r\n          this.sortOnPriorityFrom(index, node)\r\n          return\r\n        }\r\n\r\n      node.priority += 1\r\n      return this.insertInNode(node, path, data)\r\n    }\r\n\r\n    // Set data to node\r\n    if (node.data !== null) throw new Error(`Found duplicate routes`)\r\n    else node.data = data\r\n  }\r\n\r\n  /** Sort based on priority */\r\n  private sortOnPriorityFrom(position: number, node: Node<P>) {\r\n    const children = node.childValues\r\n    const index = node.childIndex\r\n    const priority = children[position].priority\r\n\r\n    let newPosition = position\r\n    while (newPosition > 0 && children[newPosition - 1].priority < priority) {\r\n      ;[children[newPosition], children[newPosition - 1]] = [\r\n        children[newPosition - 1],\r\n        children[newPosition],\r\n      ]\r\n      newPosition--\r\n    }\r\n\r\n    if (newPosition !== position)\r\n      node.childIndex =\r\n        index.slice(0, newPosition) +\r\n        index[position] +\r\n        index.slice(newPosition, position) +\r\n        index.slice(position + 1)\r\n  }\r\n\r\n  /** Find common prefix's length */\r\n  private findCommonPrefixLength(a: string, b: string) {\r\n    const m = Math.min(a.length, b.length)\r\n    let index = 0\r\n    while (index < m && a[index] === b[index]) index++\r\n    return index\r\n  }\r\n\r\n  /** Tries inserting in the given node */\r\n  private insertInNode(node: Node<P>, path: string, data: P) {\r\n    const wildcard = this.findWildCard(path)\r\n\r\n    // If there is a wildcard\r\n    if (wildcard.startIndex > -1) {\r\n      const parameter = path.slice(wildcard.startIndex, wildcard.endIndex + 1)\r\n      const wildchildType =\r\n        parameter[0] === \":\" ? Kind.PARAMETER : Kind.CATCH_ALL\r\n\r\n      // If there is a prefix before the wildcard\r\n      if (wildcard.startIndex > 0) {\r\n        const child: Node<P> = {\r\n          type: Kind.STATIC,\r\n          path: path.slice(0, wildcard.startIndex),\r\n          data: null,\r\n          priority: 1,\r\n          childIndex: \"\",\r\n          childValues: [],\r\n          childWild: null,\r\n        }\r\n\r\n        node.childIndex += path[0]\r\n        node.childValues.push(child)\r\n\r\n        node = child\r\n      }\r\n\r\n      // If the child doesn't already exist\r\n      if (!node.childWild)\r\n        node.childWild = {\r\n          path: parameter,\r\n          type: wildchildType,\r\n          data: null,\r\n          priority: 0,\r\n          childIndex: \"\",\r\n          childValues: [],\r\n          childWild: null,\r\n        }\r\n      else if (node.childWild.path !== parameter) {\r\n        const setParameter = parameter.slice(0, -1)\r\n        const existentParameter = node.childWild.path.slice(0, -1)\r\n\r\n        throw new Error(\r\n          `Found duplicate parameters at same position - ${setParameter}, ${existentParameter}`\r\n        )\r\n      }\r\n\r\n      // If there are deeper nodes\r\n      if (wildcard.endIndex + 1 < path.length)\r\n        return this.findAndInsert(\r\n          path.slice(wildcard.startIndex),\r\n          data,\r\n          node.childWild\r\n        )\r\n\r\n      node.childWild.data = data\r\n      return\r\n    }\r\n\r\n    node.childIndex += path[0]\r\n    node.childValues.push({\r\n      type: Kind.STATIC,\r\n      path,\r\n      data,\r\n      priority: 0,\r\n      childIndex: \"\",\r\n      childValues: [],\r\n      childWild: null,\r\n    })\r\n  }\r\n\r\n  /** Finds wild card start and end index, throw's if invalid path */\r\n  private findWildCard(path: string) {\r\n    let startIndex = -1\r\n    let endIndex = path.length - 1\r\n    let type: Nullable<Kind.PARAMETER | Kind.CATCH_ALL> = null\r\n\r\n    for (let index = 0; index < path.length; index++) {\r\n      if (path[index] === \":\") {\r\n        if (startIndex > -1) throw new Error(\"Invalid path\")\r\n        startIndex = index\r\n        type = Kind.PARAMETER\r\n      }\r\n\r\n      if (path[index] === \"*\") {\r\n        if (startIndex > -1) throw new Error(\"Invalid path\")\r\n        startIndex = index\r\n        type = Kind.CATCH_ALL\r\n        break\r\n      }\r\n\r\n      if (path[index] === \"/\") {\r\n        if (startIndex > -1) {\r\n          endIndex = index\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    return { startIndex, endIndex, type }\r\n  }\r\n\r\n  /** Lookup a node */\r\n  lookup(path: string) {\r\n    let node: Node<P> = this.root\r\n    let data: Nullable<P> = null\r\n    const parameters: Record<string, string> = {}\r\n\r\n    NEXT_NODE: while (true) {\r\n      if (path.length > node.path.length) {\r\n        if (path.slice(0, node.path.length) === node.path) {\r\n          path = path.slice(node.path.length)\r\n\r\n          const character = path[0]\r\n          const childIndex = node.childIndex\r\n\r\n          for (let index = 0; index < childIndex.length; index++) {\r\n            if (character === childIndex[index]) {\r\n              node = node.childValues[index]\r\n              continue NEXT_NODE\r\n            }\r\n          }\r\n\r\n          if (node.childWild) {\r\n            node = node.childWild\r\n\r\n            switch (node.type) {\r\n              case Kind.PARAMETER:\r\n                let slashIndex = 0\r\n                while (slashIndex < path.length && path[slashIndex] !== \"/\")\r\n                  slashIndex++\r\n\r\n                parameters[node.path.slice(1, -1)] = path.slice(0, slashIndex)\r\n\r\n                if (path.length > slashIndex + 1) {\r\n                  if (node.childValues.length > 0) {\r\n                    path = path.slice(slashIndex + 1)\r\n\r\n                    const character = path[0]\r\n                    const childIndex = node.childIndex\r\n\r\n                    for (let index = 0; index < childIndex.length; index++) {\r\n                      if (character === childIndex[index]) {\r\n                        node = node.childValues[index]\r\n                        continue NEXT_NODE\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  return null\r\n                }\r\n\r\n                return { data: node.data, parameters }\r\n\r\n              case Kind.CATCH_ALL:\r\n                parameters[node.path.slice(1, -1)] = path\r\n                return { data: node.data, parameters }\r\n            }\r\n          }\r\n        }\r\n      } else if (path === node.path) {\r\n        data = node.data\r\n      }\r\n\r\n      if (data) return { data, parameters }\r\n      else return null\r\n    }\r\n  }\r\n}\r\n"],"names":["Kind","MULTI_SLASH_REGEX","root","type","ROOT","path","data","priority","childIndex","childValues","childWild","add","this","findAndInsert","replace","node","commonPrefixLength","findCommonPrefixLength","Error","length","child","slice","STATIC","index","sortOnPriorityFrom","insertInNode","position","children","newPosition","a","b","m","Math","min","wildcard","findWildCard","startIndex","parameter","endIndex","wildchildType","PARAMETER","CATCH_ALL","push","setParameter","existentParameter","lookup","parameters","NEXT_NODE","character","slashIndex"],"mappings":"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"}