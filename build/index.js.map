{"version":3,"file":"index.js","sources":["../source/helpers/tree.ts"],"sourcesContent":["enum Kind {\r\n  ROOT,\r\n  STATIC,\r\n  PARAMETER,\r\n  CATCH_ALL,\r\n}\r\n\r\ntype Nullable<V> = V | null\r\n\r\ninterface Node<P, K = Kind> {\r\n  type: K\r\n  path: string\r\n  data: Nullable<P>\r\n\r\n  childIndex: string\r\n  childValues: Node<P>[]\r\n  childWild: Nullable<Node<P, Kind.PARAMETER | Kind.CATCH_ALL>>\r\n}\r\n\r\nconst MULTI_SLASH_REGEX = /\\/+|(?<!\\/)($|^)/g\r\n\r\nexport class Tree<P> {\r\n  root: Node<P, Kind.ROOT> = {\r\n    type: Kind.ROOT,\r\n    path: \"/\",\r\n    data: null,\r\n\r\n    childIndex: \"\",\r\n    childValues: [],\r\n    childWild: null,\r\n  }\r\n\r\n  /** Add new node */\r\n  public add(path: string, data: P) {\r\n    this.findAndInsert(path.replace(MULTI_SLASH_REGEX, \"/\"), data, this.root)\r\n  }\r\n\r\n  /** Finds branch and inserts node */\r\n  private findAndInsert(path: string, data: P, node: Node<P>): void {\r\n    const commonPrefixLength = this.findCommonPrefixLength(path, node.path)\r\n    if (commonPrefixLength === 0) throw new Error(\"Cannot add child node\")\r\n\r\n    // Split edge\r\n    if (commonPrefixLength < node.path.length) {\r\n      const child: Node<P> = {\r\n        path: node.path.slice(commonPrefixLength),\r\n        type: node.type,\r\n        data: node.data,\r\n        childIndex: node.childIndex,\r\n        childValues: node.childValues,\r\n        childWild: node.childWild,\r\n      }\r\n\r\n      node.type = Kind.STATIC\r\n      node.data = null\r\n      node.childIndex = node.path[commonPrefixLength]\r\n      node.path = node.path.slice(0, commonPrefixLength)\r\n      node.childValues = [child]\r\n      node.childWild = null\r\n    }\r\n\r\n    // Add child node\r\n    if (commonPrefixLength < path.length) {\r\n      path = path.slice(commonPrefixLength)\r\n      const childIndex = path[0]\r\n\r\n      for (let index = 0; index < node.childIndex.length; index++)\r\n        if (childIndex === node.childIndex[index])\r\n          return this.findAndInsert(path, data, node.childValues[index])\r\n\r\n      return this.insertInNode(node, path, data)\r\n    }\r\n\r\n    // Set data to node\r\n    if (node.data !== null) throw new Error(`Found duplicate routes`)\r\n    else node.data = data\r\n  }\r\n\r\n  /** Find common prefix's length */\r\n  private findCommonPrefixLength(a: string, b: string) {\r\n    const m = Math.min(a.length, b.length)\r\n    let index = 0\r\n    while (index < m && a[index] === b[index]) index++\r\n    return index\r\n  }\r\n\r\n  /** Tries inserting in the given node */\r\n  private insertInNode(node: Node<P>, path: string, data: P) {\r\n    const wildcard = this.findWildCard(path)\r\n\r\n    // If there is a wildcard\r\n    if (wildcard.startIndex > -1) {\r\n      const parameter = path.slice(wildcard.startIndex, wildcard.endIndex + 1)\r\n      const wildchildType =\r\n        parameter[0] === \":\" ? Kind.PARAMETER : Kind.CATCH_ALL\r\n\r\n      // If there is a prefix before the wildcard\r\n      if (wildcard.startIndex > 0) {\r\n        const child: Node<P> = {\r\n          type: Kind.STATIC,\r\n          path: path.slice(0, wildcard.startIndex),\r\n          data: null,\r\n          childIndex: \"\",\r\n          childValues: [],\r\n          childWild: null,\r\n        }\r\n\r\n        node.childIndex += path[0]\r\n        node.childValues.push(child)\r\n\r\n        node = child\r\n      }\r\n\r\n      // If the child doesn't already exist\r\n      if (!node.childWild)\r\n        node.childWild = {\r\n          path: parameter,\r\n          type: wildchildType,\r\n          data: null,\r\n          childIndex: \"\",\r\n          childValues: [],\r\n          childWild: null,\r\n        }\r\n      else if (node.childWild.path !== parameter) {\r\n        const setParameter = parameter.slice(0, -1)\r\n        const existentParameter = node.childWild.path.slice(0, -1)\r\n\r\n        throw new Error(\r\n          `Found duplicate parameters at same position - ${setParameter}, ${existentParameter}`\r\n        )\r\n      }\r\n\r\n      // If there are deeper nodes\r\n      if (wildcard.endIndex + 1 < path.length)\r\n        return this.findAndInsert(\r\n          path.slice(wildcard.startIndex),\r\n          data,\r\n          node.childWild\r\n        )\r\n\r\n      // No deeper nodes\r\n      if (node.childWild.data)\r\n        throw new Error(\"A wild card route is already registered\")\r\n\r\n      node.childWild.data = data\r\n      return\r\n    }\r\n\r\n    node.childIndex += path[0]\r\n\r\n    node.childValues.push({\r\n      type: Kind.STATIC,\r\n      path,\r\n      data,\r\n      childIndex: \"\",\r\n      childValues: [],\r\n      childWild: null,\r\n    })\r\n  }\r\n\r\n  /** Finds wild card start and end index, throw's if invalid path */\r\n  private findWildCard(path: string) {\r\n    let startIndex = -1\r\n    let endIndex = path.length - 1\r\n    let type: Nullable<Kind.PARAMETER | Kind.CATCH_ALL> = null\r\n\r\n    for (let index = 0; index < path.length; index++) {\r\n      if (path[index] === \":\") {\r\n        if (startIndex > -1) throw new Error(\"Invalid path\")\r\n        startIndex = index\r\n        type = Kind.PARAMETER\r\n      }\r\n\r\n      if (path[index] === \"*\") {\r\n        if (startIndex > -1) throw new Error(\"Invalid path\")\r\n        startIndex = index\r\n        type = Kind.CATCH_ALL\r\n        break\r\n      }\r\n\r\n      if (path[index] === \"/\") {\r\n        if (startIndex > -1) {\r\n          endIndex = index\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    return { startIndex, endIndex, type }\r\n  }\r\n\r\n  /** Lookup a node */\r\n  lookup(path: string) {\r\n    let currentNode: Node<P> = this.root\r\n    let data: Nullable<P> = null\r\n    const parameters: Record<string, string> = {}\r\n\r\n    NEXT_NODE: while (true) {\r\n      if (path.length < currentNode.path.length) break\r\n\r\n      if (path === currentNode.path) {\r\n        data = currentNode.data\r\n        break\r\n      }\r\n\r\n      if (path.slice(0, currentNode.path.length) !== currentNode.path) break\r\n      else path = path.slice(currentNode.path.length)\r\n\r\n      const character = path[0]\r\n      const childIndex = currentNode.childIndex\r\n\r\n      for (let index = 0; index < childIndex.length; index++) {\r\n        if (character === childIndex[index]) {\r\n          currentNode = currentNode.childValues[index]\r\n          continue NEXT_NODE\r\n        }\r\n      }\r\n\r\n      if (currentNode.childWild) {\r\n        const wildChild = currentNode.childWild\r\n        let parameterEndIndex = 0\r\n\r\n        if (wildChild.type === Kind.PARAMETER)\r\n          while (\r\n            path[parameterEndIndex] !== \"/\" &&\r\n            parameterEndIndex < path.length\r\n          )\r\n            parameterEndIndex++\r\n        else parameterEndIndex = path.length - 1\r\n\r\n        parameters[wildChild.path.slice(1, -1)] = path.slice(\r\n          0,\r\n          parameterEndIndex\r\n        )\r\n\r\n        path = path.slice(parameterEndIndex + 1)\r\n\r\n        if (path.length > 0) {\r\n          const character = path[0]\r\n          const childIndex = wildChild.childIndex\r\n\r\n          for (let index = 0; index < childIndex.length; index++) {\r\n            if (character === childIndex[index]) {\r\n              currentNode = wildChild.childValues[index]\r\n              continue NEXT_NODE\r\n            }\r\n          }\r\n        } else data = wildChild.data\r\n      }\r\n    }\r\n\r\n    if (data) return { data, parameters }\r\n    else return null\r\n  }\r\n}\r\n"],"names":["Kind","MULTI_SLASH_REGEX","root","type","ROOT","path","data","childIndex","childValues","childWild","add","this","findAndInsert","replace","node","commonPrefixLength","findCommonPrefixLength","Error","length","child","slice","STATIC","index","insertInNode","a","b","m","Math","min","wildcard","findWildCard","startIndex","parameter","endIndex","wildchildType","PARAMETER","CATCH_ALL","push","setParameter","existentParameter","lookup","currentNode","parameters","NEXT_NODE","character","wildChild","parameterEndIndex"],"mappings":"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"}