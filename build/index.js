"use strict";var t;Object.defineProperty(exports,"__esModule",{value:!0}),function(t){t[t.ROOT=0]="ROOT",t[t.STATIC=1]="STATIC",t[t.PARAMETER=2]="PARAMETER",t[t.CATCH_ALL=3]="CATCH_ALL"}(t||(t={}));const i=/\/+|(?<!\/)($|^)/g;exports.Tree=class{root={type:t.ROOT,path:"/",data:null,priority:0,childIndex:"",childValues:[],childWild:null};add(t,l){this.findAndInsert(t.replace(i,"/"),l,this.root)}findAndInsert(i,l,e){const d=this.findCommonPrefixLength(i,e.path);if(0===d)throw new Error("Cannot add child node");if(d<e.path.length){const i={path:e.path.slice(d),type:e.type,data:e.data,priority:e.priority,childIndex:e.childIndex,childValues:e.childValues,childWild:e.childWild};e.type=t.STATIC,e.data=null,e.childIndex=e.path[d],e.path=e.path.slice(0,d),e.priority+=1,e.childValues=[i],e.childWild=null}if(d<i.length){const t=(i=i.slice(d))[0];for(let d=0;d<e.childIndex.length;d++)if(t===e.childIndex[d])return e.priority+=1,this.findAndInsert(i,l,e.childValues[d]),void this.sortOnPriorityFrom(d,e);return e.priority+=1,this.insertInNode(e,i,l)}if(null!==e.data)throw new Error("Found duplicate routes");e.data=l}sortOnPriorityFrom(t,i){const l=i.childValues,e=i.childIndex,d=l[t].priority;let n=t;for(;n>0&&l[n-1].priority<d;)[l[n],l[n-1]]=[l[n-1],l[n]],n--;n!==t&&(i.childIndex=e.slice(0,n)+e[t]+e.slice(n,t)+e.slice(t+1))}findCommonPrefixLength(t,i){const l=Math.min(t.length,i.length);let e=0;for(;e<l&&t[e]===i[e];)e++;return e}insertInNode(i,l,e){const d=this.findWildCard(l);if(d.startIndex>-1){const n=l.slice(d.startIndex,d.endIndex+1),r=":"===n[0]?t.PARAMETER:t.CATCH_ALL;if(d.startIndex>0){const e={type:t.STATIC,path:l.slice(0,d.startIndex),data:null,priority:1,childIndex:"",childValues:[],childWild:null};i.childIndex+=l[0],i.childValues.push(e),i=e}if(i.childWild){if(i.childWild.path!==n){const t=n.slice(0,-1),l=i.childWild.path.slice(0,-1);throw new Error(`Found duplicate parameters at same position - ${t}, ${l}`)}}else i.childWild={path:n,type:r,data:null,priority:0,childIndex:"",childValues:[],childWild:null};return d.endIndex+1<l.length?this.findAndInsert(l.slice(d.startIndex),e,i.childWild):void(i.childWild.data=e)}i.childIndex+=l[0],i.childValues.push({type:t.STATIC,path:l,data:e,priority:0,childIndex:"",childValues:[],childWild:null})}findWildCard(i){let l=-1,e=i.length-1,d=null;for(let n=0;n<i.length;n++){if(":"===i[n]){if(l>-1)throw new Error("Invalid path");l=n,d=t.PARAMETER}if("*"===i[n]){if(l>-1)throw new Error("Invalid path");l=n,d=t.CATCH_ALL;break}if("/"===i[n]&&l>-1){e=n;break}}return{startIndex:l,endIndex:e,type:d}}lookup(i){let l=this.root,e=null;const d={};t:for(;;){if(i.length>l.path.length){if(i.slice(0,l.path.length)===l.path){const e=(i=i.slice(l.path.length))[0],n=l.childIndex;for(let t=0;t<n.length;t++)if(e===n[t]){l=l.childValues[t];continue t}if(l.childWild)switch(l=l.childWild,l.type){case t.PARAMETER:let e=0;for(;e<i.length&&"/"!==i[e];)e++;if(d[l.path.slice(1,-1)]=i.slice(0,e),i.length>e+1){if(l.childValues.length>0){const t=(i=i.slice(e+1))[0],d=l.childIndex;for(let i=0;i<d.length;i++)if(t===d[i]){l=l.childValues[i];continue t}}return null}return{data:l.data,parameters:d};case t.CATCH_ALL:return d[l.path.slice(1,-1)]=i,{data:l.data,parameters:d}}}}else i===l.path&&(e=l.data);return e?{data:e,parameters:d}:null}}};
//# sourceMappingURL=index.js.map
