"use strict";var l;Object.defineProperty(exports,"__esModule",{value:!0}),function(l){l[l.ROOT=0]="ROOT",l[l.STATIC=1]="STATIC",l[l.PARAMETER=2]="PARAMETER",l[l.CATCH_ALL=3]="CATCH_ALL"}(l||(l={}));const e=/\/+|(?<!\/)($|^)/g;exports.Tree=class{root={type:l.ROOT,path:"/",data:null,childIndex:"",childValues:[],childWild:null};add(l,t){this.findAndInsert(l.replace(e,"/"),t,this.root)}findAndInsert(e,t,d){const i=this.findCommonPrefixLength(e,d.path);if(0===i)throw new Error("Cannot add child node");if(i<d.path.length){const e={path:d.path.slice(i),type:d.type,data:d.data,childIndex:d.childIndex,childValues:d.childValues,childWild:d.childWild};d.type=l.STATIC,d.data=null,d.childIndex=d.path[i],d.path=d.path.slice(0,i),d.childValues=[e],d.childWild=null}if(i<e.length){const l=(e=e.slice(i))[0];for(let i=0;i<d.childIndex.length;i++)if(l===d.childIndex[i])return this.findAndInsert(e,t,d.childValues[i]);return this.insertInNode(d,e,t)}if(null!==d.data)throw new Error("Found duplicate routes");d.data=t}findCommonPrefixLength(l,e){const t=Math.min(l.length,e.length);let d=0;for(;d<t&&l[d]===e[d];)d++;return d}insertInNode(e,t,d){const i=this.findWildCard(t);if(i.startIndex>-1){const n=t.slice(i.startIndex,i.endIndex+1),h=":"===n[0]?l.PARAMETER:l.CATCH_ALL;if(i.startIndex>0){const d={type:l.STATIC,path:t.slice(0,i.startIndex),data:null,childIndex:"",childValues:[],childWild:null};e.childIndex+=t[0],e.childValues.push(d),e=d}if(e.childWild){if(e.childWild.path!==n){const l=n.slice(0,-1),t=e.childWild.path.slice(0,-1);throw new Error(`Found duplicate parameters at same position - ${l}, ${t}`)}}else e.childWild={path:n,type:h,data:null,childIndex:"",childValues:[],childWild:null};if(i.endIndex+1<t.length)return this.findAndInsert(t.slice(i.startIndex),d,e.childWild);if(e.childWild.data)throw new Error("A wild card route is already registered");e.childWild.data=d}else e.childIndex+=t[0],e.childValues.push({type:l.STATIC,path:t,data:d,childIndex:"",childValues:[],childWild:null})}findWildCard(e){let t=-1,d=e.length-1,i=null;for(let n=0;n<e.length;n++){if(":"===e[n]){if(t>-1)throw new Error("Invalid path");t=n,i=l.PARAMETER}if("*"===e[n]){if(t>-1)throw new Error("Invalid path");t=n,i=l.CATCH_ALL;break}if("/"===e[n]&&t>-1){d=n;break}}return{startIndex:t,endIndex:d,type:i}}lookup(e){let t=this.root,d=null;const i={};l:for(;!(e.length<t.path.length);){if(e===t.path){d=t.data;break}if(e.slice(0,t.path.length)!==t.path)break;const n=(e=e.slice(t.path.length))[0],h=t.childIndex;for(let l=0;l<h.length;l++)if(n===h[l]){t=t.childValues[l];continue l}if(t.childWild){const n=t.childWild;let h=0;if(n.type===l.PARAMETER)for(;"/"!==e[h]&&h<e.length;)h++;else h=e.length-1;if(i[n.path.slice(1,-1)]=e.slice(0,h),(e=e.slice(h+1)).length>0){const l=e[0],d=n.childIndex;for(let e=0;e<d.length;e++)if(l===d[e]){t=n.childValues[e];continue l}}else d=n.data}}return d?{data:d,parameters:i}:null}};
//# sourceMappingURL=index.js.map
