{"version":3,"file":"index.js","sources":["../source/helpers/tree.ts"],"sourcesContent":["enum Kind {\r\n  ROOT,\r\n  STATIC,\r\n  PARAMETER,\r\n  CATCH_ALL,\r\n}\r\n\r\ntype Nullable<V> = V | null\r\n\r\ninterface Node<P, K = Kind> {\r\n  type: K\r\n  path: string\r\n  data: Nullable<P>\r\n  priority: number\r\n\r\n  childIndex: string\r\n  childValues: Node<P>[]\r\n  childWild: Nullable<Node<P, Kind.PARAMETER | Kind.CATCH_ALL>>\r\n}\r\n\r\nexport class Tree<P> {\r\n  root: Node<P, Kind.ROOT> = {\r\n    type: Kind.ROOT,\r\n    path: \"/\",\r\n    data: null,\r\n    priority: 0,\r\n\r\n    childIndex: \"\",\r\n    childValues: [],\r\n    childWild: null,\r\n  }\r\n\r\n  /** Finds branch and inserts node */\r\n  public add(path: string, data: P, node: Node<P> = this.root): void {\r\n    const commonPrefixLength = this.findCommonPrefixLength(path, node.path)\r\n    if (commonPrefixLength === 0) throw new Error(\"Cannot add child node\")\r\n\r\n    // Split edge\r\n    if (commonPrefixLength < node.path.length) {\r\n      const child: Node<P> = {\r\n        path: node.path.slice(commonPrefixLength),\r\n        type: node.type,\r\n        data: node.data,\r\n        priority: node.priority,\r\n        childIndex: node.childIndex,\r\n        childValues: node.childValues,\r\n        childWild: node.childWild,\r\n      }\r\n\r\n      node.type = Kind.STATIC\r\n      node.data = null\r\n      node.childIndex = node.path[commonPrefixLength]\r\n      node.path = node.path.slice(0, commonPrefixLength)\r\n      node.priority += 1\r\n      node.childValues = [child]\r\n      node.childWild = null\r\n    }\r\n\r\n    // Add child node\r\n    if (commonPrefixLength < path.length) {\r\n      path = path.slice(commonPrefixLength)\r\n      const childIndex = path[0]\r\n\r\n      for (let index = 0; index < node.childIndex.length; index++)\r\n        if (childIndex === node.childIndex[index]) {\r\n          node.priority += 1\r\n          this.add(path, data, node.childValues[index])\r\n          this.sortOnPriorityFrom(index, node)\r\n          return\r\n        }\r\n\r\n      node.priority += 1\r\n      return this.insertInNode(node, path, data)\r\n    }\r\n\r\n    // Set data to node\r\n    if (node.data !== null) throw new Error(`Found duplicate routes`)\r\n    else node.data = data\r\n  }\r\n\r\n  /** Sort based on priority */\r\n  private sortOnPriorityFrom(position: number, node: Node<P>) {\r\n    const children = node.childValues\r\n    const index = node.childIndex\r\n    const priority = children[position].priority\r\n\r\n    let newPosition = position\r\n    while (newPosition > 0 && children[newPosition - 1].priority < priority) {\r\n      ;[children[newPosition], children[newPosition - 1]] = [\r\n        children[newPosition - 1],\r\n        children[newPosition],\r\n      ]\r\n      newPosition--\r\n    }\r\n\r\n    if (newPosition !== position)\r\n      node.childIndex =\r\n        index.slice(0, newPosition) +\r\n        index[position] +\r\n        index.slice(newPosition, position) +\r\n        index.slice(position + 1)\r\n  }\r\n\r\n  /** Find common prefix's length */\r\n  private findCommonPrefixLength(a: string, b: string) {\r\n    const m = Math.min(a.length, b.length)\r\n    let index = 0\r\n    while (index < m && a[index] === b[index]) index++\r\n    return index\r\n  }\r\n\r\n  /** Tries inserting in the given node */\r\n  private insertInNode(node: Node<P>, path: string, data: P) {\r\n    const wildcard = this.findWildCard(path)\r\n\r\n    // If there is a wildcard\r\n    if (wildcard.startIndex > -1) {\r\n      const parameter = path.slice(wildcard.startIndex, wildcard.endIndex + 1)\r\n      const wildchildType =\r\n        parameter[0] === \":\" ? Kind.PARAMETER : Kind.CATCH_ALL\r\n\r\n      // If there is a prefix before the wildcard\r\n      if (wildcard.startIndex > 0) {\r\n        const child: Node<P> = {\r\n          type: Kind.STATIC,\r\n          path: path.slice(0, wildcard.startIndex),\r\n          data: null,\r\n          priority: 1,\r\n          childIndex: \"\",\r\n          childValues: [],\r\n          childWild: null,\r\n        }\r\n\r\n        node.childIndex += path[0]\r\n        node.childValues.push(child)\r\n\r\n        node = child\r\n      }\r\n\r\n      // If the child doesn't already exist\r\n      if (!node.childWild)\r\n        node.childWild = {\r\n          path: parameter,\r\n          type: wildchildType,\r\n          data: null,\r\n          priority: 0,\r\n          childIndex: \"\",\r\n          childValues: [],\r\n          childWild: null,\r\n        }\r\n      else if (node.childWild.path !== parameter) {\r\n        const setParameter = parameter.slice(0, -1)\r\n        const existentParameter = node.childWild.path.slice(0, -1)\r\n\r\n        throw new Error(\r\n          `Found duplicate parameters at same position - ${setParameter}, ${existentParameter}`\r\n        )\r\n      }\r\n\r\n      // If there are deeper nodes\r\n      if (wildcard.endIndex + 1 < path.length)\r\n        return this.add(path.slice(wildcard.startIndex), data, node.childWild)\r\n\r\n      node.childWild.data = data\r\n      return\r\n    }\r\n\r\n    node.childIndex += path[0]\r\n    node.childValues.push({\r\n      type: Kind.STATIC,\r\n      path,\r\n      data,\r\n      priority: 0,\r\n      childIndex: \"\",\r\n      childValues: [],\r\n      childWild: null,\r\n    })\r\n  }\r\n\r\n  /** Finds wild card start and end index, throw's if invalid path */\r\n  private findWildCard(path: string) {\r\n    let startIndex = -1\r\n    let endIndex = path.length - 1\r\n    let type: Nullable<Kind.PARAMETER | Kind.CATCH_ALL> = null\r\n\r\n    for (let index = 0; index < path.length; index++) {\r\n      if (path[index] === \":\") {\r\n        if (startIndex > -1) throw new Error(\"Invalid path\")\r\n        startIndex = index\r\n        type = Kind.PARAMETER\r\n      }\r\n\r\n      if (path[index] === \"*\") {\r\n        if (startIndex > -1) throw new Error(\"Invalid path\")\r\n        startIndex = index\r\n        type = Kind.CATCH_ALL\r\n        break\r\n      }\r\n\r\n      if (path[index] === \"/\") {\r\n        if (startIndex > -1) {\r\n          endIndex = index\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    return { startIndex, endIndex, type }\r\n  }\r\n\r\n  /** Lookup a node */\r\n  lookup(path: string) {\r\n    let node: Node<P> = this.root\r\n    let data: Nullable<P> = null\r\n    const parameters: Record<string, string> = {}\r\n\r\n    NEXT_NODE: while (true) {\r\n      if (path.length > node.path.length) {\r\n        if (path.slice(0, node.path.length) === node.path) {\r\n          path = path.slice(node.path.length)\r\n\r\n          const character = path[0]\r\n          const childIndex = node.childIndex\r\n\r\n          for (let index = 0; index < childIndex.length; index++) {\r\n            if (character === childIndex[index]) {\r\n              node = node.childValues[index]\r\n              continue NEXT_NODE\r\n            }\r\n          }\r\n\r\n          if (node.childWild) {\r\n            node = node.childWild\r\n\r\n            switch (node.type) {\r\n              case Kind.PARAMETER:\r\n                let slashIndex = 0\r\n                while (slashIndex < path.length && path[slashIndex] !== \"/\")\r\n                  slashIndex++\r\n\r\n                parameters[node.path.slice(1, -1)] = path.slice(0, slashIndex)\r\n\r\n                if (path.length > slashIndex + 1) {\r\n                  if (node.childValues.length > 0) {\r\n                    path = path.slice(slashIndex + 1)\r\n\r\n                    const character = path[0]\r\n                    const childIndex = node.childIndex\r\n\r\n                    for (let index = 0; index < childIndex.length; index++) {\r\n                      if (character === childIndex[index]) {\r\n                        node = node.childValues[index]\r\n                        continue NEXT_NODE\r\n                      }\r\n                    }\r\n                  }\r\n\r\n                  return null\r\n                }\r\n\r\n                if (node.data) return { data: node.data, parameters }\r\n                else return null\r\n\r\n              case Kind.CATCH_ALL:\r\n                parameters[node.path.slice(1, -1)] = path\r\n\r\n                if (node.data) return { data: node.data, parameters }\r\n                else return null\r\n            }\r\n          }\r\n        }\r\n      } else if (path === node.path) {\r\n        data = node.data\r\n      }\r\n\r\n      if (data) return { data, parameters }\r\n      else return null\r\n    }\r\n  }\r\n}\r\n"],"names":["Kind","root","type","ROOT","path","data","priority","childIndex","childValues","childWild","add","node","this","commonPrefixLength","findCommonPrefixLength","Error","length","child","slice","STATIC","index","sortOnPriorityFrom","insertInNode","position","children","newPosition","a","b","m","Math","min","wildcard","findWildCard","startIndex","parameter","endIndex","wildchildType","PARAMETER","CATCH_ALL","push","setParameter","existentParameter","lookup","parameters","NEXT_NODE","character","slashIndex"],"mappings":"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"}