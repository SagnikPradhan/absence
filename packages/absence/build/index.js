"use strict";var t;Object.defineProperty(exports,"__esModule",{value:!0}),function(t){t[t.ROOT=0]="ROOT",t[t.STATIC=1]="STATIC",t[t.PARAMETER=2]="PARAMETER",t[t.CATCH_ALL=3]="CATCH_ALL"}(t||(t={}));exports.Tree=class{root={type:t.ROOT,path:"/",data:null,priority:0,childIndex:"",childValues:[],childWild:null};add(l,i,e=this.root){const d=this.findCommonPrefixLength(l,e.path);if(0===d)throw new Error("Cannot add child node");if(d<e.path.length){const l={path:e.path.slice(d),type:e.type,data:e.data,priority:e.priority,childIndex:e.childIndex,childValues:e.childValues,childWild:e.childWild};e.type=t.STATIC,e.data=null,e.childIndex=e.path[d],e.path=e.path.slice(0,d),e.priority+=1,e.childValues=[l],e.childWild=null}if(d<l.length){const t=(l=l.slice(d))[0];for(let d=0;d<e.childIndex.length;d++)if(t===e.childIndex[d])return e.priority+=1,this.add(l,i,e.childValues[d]),void this.sortOnPriorityFrom(d,e);return e.priority+=1,this.insertInNode(e,l,i)}if(null!==e.data)throw new Error("Found duplicate routes");e.data=i}sortOnPriorityFrom(t,l){const i=l.childValues,e=l.childIndex,d=i[t].priority;let n=t;for(;n>0&&i[n-1].priority<d;)[i[n],i[n-1]]=[i[n-1],i[n]],n--;n!==t&&(l.childIndex=e.slice(0,n)+e[t]+e.slice(n,t)+e.slice(t+1))}findCommonPrefixLength(t,l){const i=Math.min(t.length,l.length);let e=0;for(;e<i&&t[e]===l[e];)e++;return e}insertInNode(l,i,e){const d=this.findWildCard(i);if(d.startIndex>-1){const n=i.slice(d.startIndex,d.endIndex+1),r=":"===n[0]?t.PARAMETER:t.CATCH_ALL;if(d.startIndex>0){const e={type:t.STATIC,path:i.slice(0,d.startIndex),data:null,priority:1,childIndex:"",childValues:[],childWild:null};l.childIndex+=i[0],l.childValues.push(e),l=e}if(l.childWild){if(l.childWild.path!==n){const t=n.slice(0,-1),i=l.childWild.path.slice(0,-1);throw new Error(`Found duplicate parameters at same position - ${t}, ${i}`)}}else l.childWild={path:n,type:r,data:null,priority:0,childIndex:"",childValues:[],childWild:null};return d.endIndex+1<i.length?this.add(i.slice(d.startIndex),e,l.childWild):void(l.childWild.data=e)}l.childIndex+=i[0],l.childValues.push({type:t.STATIC,path:i,data:e,priority:0,childIndex:"",childValues:[],childWild:null})}findWildCard(l){let i=-1,e=l.length-1,d=null;for(let n=0;n<l.length;n++){if(":"===l[n]){if(i>-1)throw new Error("Invalid path");i=n,d=t.PARAMETER}if("*"===l[n]){if(i>-1)throw new Error("Invalid path");i=n,d=t.CATCH_ALL;break}if("/"===l[n]&&i>-1){e=n;break}}return{startIndex:i,endIndex:e,type:d}}lookup(l){let i=this.root,e=null;const d={};t:for(;;){if(l.length>i.path.length){if(l.slice(0,i.path.length)===i.path){const e=(l=l.slice(i.path.length))[0],n=i.childIndex;for(let t=0;t<n.length;t++)if(e===n[t]){i=i.childValues[t];continue t}if(i.childWild)switch(i=i.childWild,i.type){case t.PARAMETER:let e=0;for(;e<l.length&&"/"!==l[e];)e++;if(d[i.path.slice(1,-1)]=l.slice(0,e),l.length>e+1){if(i.childValues.length>0){const t=(l=l.slice(e+1))[0],d=i.childIndex;for(let l=0;l<d.length;l++)if(t===d[l]){i=i.childValues[l];continue t}}return null}return i.data?{data:i.data,parameters:d}:null;case t.CATCH_ALL:return d[i.path.slice(1,-1)]=l,i.data?{data:i.data,parameters:d}:null}}}else l===i.path&&(e=i.data);return e?{data:e,parameters:d}:null}}};
//# sourceMappingURL=index.js.map
