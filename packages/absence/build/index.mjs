var l;!function(l){l[l.ROOT=0]="ROOT",l[l.STATIC=1]="STATIC",l[l.PARAMETER=2]="PARAMETER",l[l.CATCH_ALL=3]="CATCH_ALL"}(l||(l={}));class t{root={type:l.ROOT,path:"/",data:null,priority:0,childIndex:"",childValues:[],childWild:null};add(t,i,e=this.root){const d=this.findCommonPrefixLength(t,e.path);if(0===d)throw new Error("Cannot add child node");if(d<e.path.length){const t={path:e.path.slice(d),type:e.type,data:e.data,priority:e.priority,childIndex:e.childIndex,childValues:e.childValues,childWild:e.childWild};e.type=l.STATIC,e.data=null,e.childIndex=e.path[d],e.path=e.path.slice(0,d),e.priority+=1,e.childValues=[t],e.childWild=null}if(d<t.length){const l=(t=t.slice(d))[0];for(let d=0;d<e.childIndex.length;d++)if(l===e.childIndex[d])return e.priority+=1,this.add(t,i,e.childValues[d]),void this.sortOnPriorityFrom(d,e);return e.priority+=1,this.insertInNode(e,t,i)}if(null!==e.data)throw new Error("Found duplicate routes");e.data=i}sortOnPriorityFrom(l,t){const i=t.childValues,e=t.childIndex,d=i[l].priority;let n=l;for(;n>0&&i[n-1].priority<d;)[i[n],i[n-1]]=[i[n-1],i[n]],n--;n!==l&&(t.childIndex=e.slice(0,n)+e[l]+e.slice(n,l)+e.slice(l+1))}findCommonPrefixLength(l,t){const i=Math.min(l.length,t.length);let e=0;for(;e<i&&l[e]===t[e];)e++;return e}insertInNode(t,i,e){const d=this.findWildCard(i);if(d.startIndex>-1){const n=i.slice(d.startIndex,d.endIndex+1),a=":"===n[0]?l.PARAMETER:l.CATCH_ALL;if(d.startIndex>0){const e={type:l.STATIC,path:i.slice(0,d.startIndex),data:null,priority:1,childIndex:"",childValues:[],childWild:null};t.childIndex+=i[0],t.childValues.push(e),t=e}if(t.childWild){if(t.childWild.path!==n){const l=n.slice(0,-1),i=t.childWild.path.slice(0,-1);throw new Error(`Found duplicate parameters at same position - ${l}, ${i}`)}}else t.childWild={path:n,type:a,data:null,priority:0,childIndex:"",childValues:[],childWild:null};return d.endIndex+1<i.length?this.add(i.slice(d.startIndex),e,t.childWild):void(t.childWild.data=e)}t.childIndex+=i[0],t.childValues.push({type:l.STATIC,path:i,data:e,priority:0,childIndex:"",childValues:[],childWild:null})}findWildCard(t){let i=-1,e=t.length-1,d=null;for(let n=0;n<t.length;n++){if(":"===t[n]){if(i>-1)throw new Error("Invalid path");i=n,d=l.PARAMETER}if("*"===t[n]){if(i>-1)throw new Error("Invalid path");i=n,d=l.CATCH_ALL;break}if("/"===t[n]&&i>-1){e=n;break}}return{startIndex:i,endIndex:e,type:d}}lookup(t){let i=this.root,e=null;const d={};l:for(;;){if(t.length>i.path.length){if(t.slice(0,i.path.length)===i.path){const e=(t=t.slice(i.path.length))[0],n=i.childIndex;for(let l=0;l<n.length;l++)if(e===n[l]){i=i.childValues[l];continue l}if(i.childWild)switch(i=i.childWild,i.type){case l.PARAMETER:let e=0;for(;e<t.length&&"/"!==t[e];)e++;if(d[i.path.slice(1,-1)]=t.slice(0,e),t.length>e+1){if(i.childValues.length>0){const l=(t=t.slice(e+1))[0],d=i.childIndex;for(let t=0;t<d.length;t++)if(l===d[t]){i=i.childValues[t];continue l}}return null}return i.data?{data:i.data,parameters:d}:null;case l.CATCH_ALL:return d[i.path.slice(1,-1)]=t,i.data?{data:i.data,parameters:d}:null}}}else t===i.path&&(e=i.data);return e?{data:e,parameters:d}:null}}}export{t as Tree};
//# sourceMappingURL=index.mjs.map
